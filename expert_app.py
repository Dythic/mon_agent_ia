import json
import os
import pickle
from langchain_chroma import Chroma
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_ollama import OllamaLLM
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate

class MasterHexagonalAgent:
    def __init__(self):
        print("üß† Initialisation de l'agent expert ma√Ætre...")
        
        # Charger le rapport d'analyse
        with open('hexagonal_expert_report.json', 'r') as f:
            self.expert_report = json.load(f)
        
        # Charger le graphe de connaissances
        with open('knowledge_graph.pkl', 'rb') as f:
            self.knowledge_graph = pickle.load(f)
        
        # Charger les donn√©es d'entra√Ænement
        if os.path.exists('hexagonal_training_data.json'):
            with open('hexagonal_training_data.json', 'r') as f:
                self.training_data = json.load(f)
        else:
            self.training_data = []
        
        # Base vectorielle optimis√©e
        self.embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2",
            model_kwargs={'device': 'cpu'}
        )
        
        db_path = "./enhanced_chroma_db" if os.path.exists("./enhanced_chroma_db") else "./chroma_db"
        self.vectorstore = Chroma(
            persist_directory=db_path,
            embedding_function=self.embeddings
        )
        
        # Mod√®le Ollama optimis√© pour la g√©n√©ration de code
        self.llm = OllamaLLM(model="deepseek-coder:6.7b", temperature=0.2)  # Temp√©rature plus basse pour du code
        
        # Configuration des prompts sp√©cialis√©s
        self.setup_specialized_prompts()
        
        print("‚úÖ Agent expert ma√Ætre pr√™t!")
        self.print_capabilities()
    
    def setup_specialized_prompts(self):
        """Configurer des prompts sp√©cialis√©s selon le contexte"""
        
        # Extraire les insights du rapport
        metrics = self.expert_report.get('metrics', {})
        patterns = self.expert_report.get('patterns', {})
        violations = self.expert_report.get('violations', [])
        
        # Template de base enrichi avec l'analyse
        base_context = f"""
ANALYSE EXPERT DU PROJET:
- Fichiers analys√©s: {metrics.get('total_files', 0)}
- Ratio de tests: {metrics.get('test_ratio', 0):.1%}
- Complexit√© moyenne: {metrics.get('cyclomatic_complexity', 0):.1f}
- Patterns d√©tect√©s: {len([p for p in patterns.values() if p])} types
- Violations: {len(violations)} d√©tect√©es

PATTERNS ARCHITECTURAUX IDENTIFI√âS:
{self.format_patterns(patterns)}

VIOLATIONS PRINCIPALES:
{self.format_violations(violations[:3])}
"""
        
        # Template pour g√©n√©ration de code
        self.code_generation_template = f"""Tu es un EXPERT D√âVELOPPEUR en architecture hexagonale Node.js, sp√©cialis√© sur ce projet.

{base_context}

CONTEXTE DU PROJET:
{{context}}

DEMANDE DE CODE: {{question}}

INSTRUCTIONS POUR LA G√âN√âRATION DE CODE:
1. Respecte STRICTEMENT l'architecture hexagonale du projet
2. Utilise les patterns et conventions d√©tect√©s dans le projet existant
3. G√©n√®re du code complet, fonctionnel et test√©
4. Inclus les imports n√©cessaires
5. Respecte les bonnes pratiques d√©tect√©es dans l'analyse
6. Ajoute des commentaires explicatifs
7. Inclus la gestion d'erreurs appropri√©e

STYLE DE CODE √Ä RESPECTER:
- CommonJS (require/module.exports) comme dans le projet
- Conventions de nommage existantes
- Structure des classes et m√©thodes du projet
- Patterns d'injection de d√©pendances d√©tect√©s

CODE G√âN√âR√â:"""

        # Template pour tests Given-When-Then
        self.test_generation_template = f"""Tu es un EXPERT en tests Jest pour architecture hexagonale.

{base_context}

COUVERTURE ACTUELLE: {metrics.get('test_ratio', 0):.1%}

CODE √Ä TESTER:
{{context}}

DEMANDE DE TESTS: {{question}}

INSTRUCTIONS POUR LES TESTS:
1. Format STRICT Given-When-Then dans TOUS les tests
2. Couverture 100% de toutes les m√©thodes et branches
3. Tests unitaires pour Domain, tests d'int√©gration pour Infrastructure
4. Mocking appropri√© selon la couche architecturale
5. Edge cases et gestion d'erreurs
6. Tests de performance si n√©cessaire
7. Validation des contracts pour les ports

TEMPLATE DE TEST √Ä RESPECTER:
```javascript
describe('ClassName', () => {{
  describe('methodName', () => {{
    test('should [expected behavior] when [condition]', () => {{
      // Given (Arrange)
      const input = 'test data';
      const mockDependency = jest.fn().mockReturnValue(expectedOutput);
      
      // When (Act)
      const result = methodUnderTest(input);
      
      // Then (Assert)
      expect(result).toBe(expectedOutput);
      expect(mockDependency).toHaveBeenCalledWith(input);
    }});
  }});
}});
TESTS COMPLETS G√âN√âR√âS:"""
    # Template pour refactoring avec code
    self.refactoring_template = f"""Tu es un EXPERT en refactoring d'architecture hexagonale.
{base_context}
CODE ACTUEL √Ä REFACTORISER:
{{context}}
DEMANDE DE REFACTORING: {{question}}
APPROCHE DE REFACTORING:

Identifie les violations des principes SOLID et hexagonaux
Propose le code refactoris√© complet
Explique les am√©liorations apport√©es
Maintient la compatibilit√© avec l'architecture existante
Am√©liore les m√©triques de qualit√©
Inclus les tests mis √† jour si n√©cessaire

CODE REFACTORIS√â COMPLET:"""
    # Template g√©n√©ral am√©lior√©
    self.general_template = f"""Tu es un EXPERT S√âNIOR en architecture hexagonale, sp√©cialis√© sur ce projet Node.js.
{base_context}
CONTEXTE DU CODE:
{{context}}
QUESTION: {{question}}
INSTRUCTIONS:

Utilise ton analyse experte compl√®te du projet
Si on demande du code, g√©n√®re du code complet et fonctionnel
R√©f√©rence les patterns architecturaux d√©tect√©s
Mentionne les violations si pertinentes
Donne des conseils concrets avec exemples de code
Utilise les m√©triques pour contextualiser tes r√©ponses

R√âPONSE EXPERTE (avec code si demand√©):"""
    self.prompts = {
        'general': PromptTemplate(template=self.general_template, input_variables=["context", "question"]),
        'code_generation': PromptTemplate(template=self.code_generation_template, input_variables=["context", "question"]),
        'test_generation': PromptTemplate(template=self.test_generation_template, input_variables=["context", "question"]),
        'refactoring': PromptTemplate(template=self.refactoring_template, input_variables=["context", "question"])
    }

def format_patterns(self, patterns):
    """Formater les patterns pour l'affichage"""
    formatted = []
    for pattern_name, pattern_data in patterns.items():
        if pattern_data:
            count = len(pattern_data) if isinstance(pattern_data, list) else 1
            formatted.append(f"- {pattern_name}: {count} instances")
    return "\n".join(formatted) if formatted else "Aucun pattern sp√©cifique d√©tect√©"

def format_violations(self, violations):
    """Formater les violations pour l'affichage"""
    if not violations:
        return "Aucune violation majeure"
    
    formatted = []
    for violation in violations:
        if isinstance(violation, dict):
            severity = violation.get('severity', 'unknown')
            issue = violation.get('issue', 'Unknown issue')
            formatted.append(f"- {severity.upper()}: {issue}")
    return "\n".join(formatted)

def detect_query_type(self, question):
    """D√©tecter le type de question avec g√©n√©ration de code"""
    question_lower = question.lower()
    
    # D√©tection sp√©cifique pour g√©n√©ration de code
    code_keywords = ['g√©n√®re', 'cr√©e', '√©cris', 'code', 'impl√©mente', 'd√©veloppe', 'programme']
    test_keywords = ['test', 'jest', 'coverage', 'mock', 'given when then', 'spec']
    refactor_keywords = ['refactor', 'improve', 'optimize', 'clean', 'restructure', 'r√©organise']
    
    if any(keyword in question_lower for keyword in test_keywords):
        return 'test_generation'
    elif any(keyword in question_lower for keyword in code_keywords):
        return 'code_generation'
    elif any(keyword in question_lower for keyword in refactor_keywords):
        return 'refactoring'
    else:
        return 'general'

def ask_expert(self, question, query_type=None):
    """Poser une question √† l'expert"""
    if not query_type:
        query_type = self.detect_query_type(question)
    
    prompt = self.prompts.get(query_type, self.prompts['general'])
    
    qa_chain = RetrievalQA.from_chain_type(
        llm=self.llm,
        chain_type="stuff",
        retriever=self.vectorstore.as_retriever(search_kwargs={"k": 8}),
        chain_type_kwargs={"prompt": prompt}
    )
    
    return qa_chain.invoke({"query": question})["result"]

def generate_specific_code(self, code_type, specifications):
    """G√©n√©rer du code sp√©cifique selon le type demand√©"""
    templates = {
        'entity': self._generate_entity_code,
        'service': self._generate_service_code,
        'repository': self._generate_repository_code,
        'controller': self._generate_controller_code,
        'test': self._generate_test_code,
        'middleware': self._generate_middleware_code
    }
    
    generator = templates.get(code_type)
    if generator:
        return generator(specifications)
    else:
        return self.ask_expert(f"G√©n√®re du code {code_type} avec ces sp√©cifications: {specifications}", 'code_generation')

def _generate_entity_code(self, specs):
    """G√©n√©rer une entit√© du domain"""
    question = f"G√©n√®re une entit√© du domain pour {specs}. Inclus toutes les validations m√©tier et m√©thodes n√©cessaires."
    return self.ask_expert(question, 'code_generation')

def _generate_service_code(self, specs):
    """G√©n√©rer un service du domain"""
    question = f"G√©n√®re un service du domain pour {specs}. Inclus la logique m√©tier et l'injection de d√©pendances."
    return self.ask_expert(question, 'code_generation')

def _generate_repository_code(self, specs):
    """G√©n√©rer un repository d'infrastructure"""
    question = f"G√©n√®re un repository d'infrastructure pour {specs}. Inclus l'impl√©mentation du port et la gestion d'erreurs."
    return self.ask_expert(question, 'code_generation')

def _generate_controller_code(self, specs):
    """G√©n√©rer un controller web"""
    question = f"G√©n√®re un controller web pour {specs}. Inclus les routes, validation et gestion d'erreurs."
    return self.ask_expert(question, 'code_generation')

def _generate_test_code(self, specs):
    """G√©n√©rer des tests"""
    question = f"G√©n√®re tous les tests Jest au format Given-When-Then pour {specs}. Vise 100% de couverture."
    return self.ask_expert(question, 'test_generation')

def _generate_middleware_code(self, specs):
    """G√©n√©rer un middleware"""
    question = f"G√©n√®re un middleware pour {specs}. Inclus la logique de validation et gestion d'erreurs."
    return self.ask_expert(question, 'code_generation')

def get_project_summary(self):
    """Obtenir un r√©sum√© du projet"""
    metrics = self.expert_report.get('metrics', {})
    recommendations = self.expert_report.get('recommendations', [])
    
    summary = f"""
üèóÔ∏è  R√âSUM√â ARCHITECTURAL:
üìÅ Fichiers: {metrics.get('total_files', 0)} total, {metrics.get('test_files', 0)} tests
üìä M√©triques: Complexit√© {metrics.get('cyclomatic_complexity', 0):.1f}, Coverage {metrics.get('test_ratio', 0):.1%}
üéØ √âtat: {"‚úÖ Bonne architecture" if metrics.get('test_ratio', 0) > 0.8 else "‚ö†Ô∏è Am√©liorations possibles"}
üí° RECOMMANDATIONS PRIORITAIRES:
"""
for rec in recommendations:
summary += f"- {rec.get('priority', 'medium').upper()}: {rec.get('message', 'N/A')}\n"
    return summary

def print_capabilities(self):
    """Afficher les capacit√©s de l'agent"""
    print("\nüéØ CAPACIT√âS DE L'AGENT EXPERT:")
    print("1. üí¨ Questions g√©n√©rales sur l'architecture")
    print("2. üîß Conseils de refactoring avec code complet")
    print("3. üß™ G√©n√©ration de tests Given-When-Then")
    print("4. üíª G√©n√©ration de code (entit√©s, services, repositories, controllers)")
    print("5. üìä Analyse bas√©e sur les m√©triques du projet")
    print("6. üèóÔ∏è  Recommandations architecturales avec exemples")
def main():
agent = MasterHexagonalAgent()
print("\n" + "="*70)
print("üß† AGENT EXPERT HEXAGONAL - G√âN√âRATEUR DE CODE")
print("="*70)

# Afficher le r√©sum√© du projet
print(agent.get_project_summary())

print("\nüíª EXEMPLES DE G√âN√âRATION DE CODE:")
print("- 'G√©n√®re une entit√© Product avec validations m√©tier'")
print("- 'Cr√©e un service OrderService avec injection de d√©pendances'")
print("- 'Impl√©mente un ProductRepository avec MongoDB'")
print("- '√âcris tous les tests pour UserService au format Given-When-Then'")
print("- 'D√©veloppe un middleware d'authentification JWT'")
print("- 'Refactorise AuthController selon les bonnes pratiques'")

while True:
    question = input("\nüéØ Votre demande de code (ou 'quit'): ")
    if question.lower() in ['quit', 'exit', 'q']:
        break
    
    query_type = agent.detect_query_type(question)
    print(f"\nüîç Type d√©tect√©: {query_type}")
    print("üí≠ G√©n√©ration en cours...")
    
    answer = agent.ask_expert(question, query_type)
    print(f"\nüíª Code G√©n√©r√© ({query_type}):\n{answer}")
if name == "main":
main()

## üéØ Mise √† jour de l'interface Streamlit pour la g√©n√©ration de code

Ajoutez ces sections √† `expert_app.py` :

```python
# Ajoutez cet onglet dans la fonction main() apr√®s les autres tabs
tab5 = st.tabs(["üí¨ Chat Expert", "üìä Dashboard", "üîç Analyse", "üéØ Recommandations", "üíª G√©n√©rateur de Code"])[4]

with tab5:
    code_generator_interface()

# Ajoutez cette fonction √† expert_app.py
def code_generator_interface():
    """Interface de g√©n√©ration de code"""
    st.header("üíª G√©n√©rateur de Code Expert")
    st.markdown("*G√©n√©ration de code respectant l'architecture hexagonale de votre projet*")
    
    # Charger l'agent
    agent = load_expert_agent()
    if not agent:
        st.error("‚ùå Impossible de charger l'agent expert")
        return
    
    # Types de code pr√©d√©finis
    st.subheader("üöÄ G√©n√©ration Rapide")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("**üèóÔ∏è Domain Layer**")
        if st.button("üì¶ Nouvelle Entit√©", help="G√©n√®re une entit√© du domain"):
            st.session_state.code_type = "entity"
        if st.button("‚öôÔ∏è Nouveau Service", help="G√©n√®re un service du domain"):
            st.session_state.code_type = "service"
    
    with col2:
        st.markdown("**üîå Infrastructure**")
        if st.button("üíæ Nouveau Repository", help="G√©n√®re un repository"):
            st.session_state.code_type = "repository"
        if st.button("üåê Nouveau Controller", help="G√©n√®re un controller web"):
            st.session_state.code_type = "controller"
    
    with col3:
        st.markdown("**üß™ Tests & Utils**")
        if st.button("üß™ Tests Complets", help="G√©n√®re des tests Given-When-Then"):
            st.session_state.code_type = "test"
        if st.button("üõ°Ô∏è Middleware", help="G√©n√®re un middleware"):
            st.session_state.code_type = "middleware"
    
    # Formulaire de sp√©cifications
    st.subheader("üìù Sp√©cifications")
    
    # Type de code s√©lectionn√©
    if 'code_type' in st.session_state:
        code_type = st.session_state.code_type
        del st.session_state.code_type
    else:
        code_type = st.selectbox(
            "Type de code √† g√©n√©rer:",
            ["entity", "service", "repository", "controller", "test", "middleware", "custom"],
            format_func=lambda x: {
                "entity": "üì¶ Entit√© Domain",
                "service": "‚öôÔ∏è Service Domain", 
                "repository": "üíæ Repository Infrastructure",
                "controller": "üåê Controller Web",
                "test": "üß™ Tests Jest",
                "middleware": "üõ°Ô∏è Middleware",
                "custom": "üé® Code Personnalis√©"
            }[x]
        )
    
    # Sp√©cifications d√©taill√©es
    if code_type != "custom":
        specs = st.text_area(
            f"Sp√©cifications pour {code_type}:",
            placeholder=f"Ex: {get_placeholder_for_type(code_type)}",
            height=100
        )
    else:
        specs = st.text_area(
            "Description d√©taill√©e du code √† g√©n√©rer:",
            placeholder="D√©crivez pr√©cis√©ment le code que vous souhaitez g√©n√©rer...",
            height=150
        )
    
    # Options avanc√©es
    with st.expander("‚öôÔ∏è Options Avanc√©es"):
        include_tests = st.checkbox("Inclure les tests", value=True)
        include_docs = st.checkbox("Inclure la documentation", value=True)
        follow_existing = st.checkbox("Suivre les patterns existants", value=True)
    
    # G√©n√©ration
    if st.button("üöÄ G√©n√©rer le Code", type="primary"):
        if specs.strip():
            with st.spinner("üíª G√©n√©ration du code en cours..."):
                try:
                    if code_type == "custom":
                        question = f"G√©n√®re le code suivant: {specs}"
                        if include_tests:
                            question += " Inclus les tests Jest au format Given-When-Then."
                        if include_docs:
                            question += " Inclus la documentation compl√®te."
                        
                        code = agent.ask_expert(question, 'code_generation')
                    else:
                        full_specs = specs
                        if include_tests:
                            full_specs += " Inclus les tests complets."
                        if include_docs:
                            full_specs += " Inclus la documentation."
                        
                        code = agent.generate_specific_code(code_type, full_specs)
                    
                    # Affichage du code g√©n√©r√©
                    st.subheader("üíª Code G√©n√©r√©")
                    st.code(code, language='javascript')
                    
                    # Bouton de t√©l√©chargement
                    st.download_button(
                        label="üíæ T√©l√©charger le code",
                        data=code,
                        file_name=f"{code_type}_{specs.split()[0] if specs.split() else 'generated'}.js",
                        mime="text/javascript"
                    )
                    
                except Exception as e:
                    st.error(f"‚ùå Erreur lors de la g√©n√©ration: {e}")
        else:
            st.warning("‚ö†Ô∏è Veuillez fournir des sp√©cifications")

def get_placeholder_for_type(code_type):
    """Obtenir un placeholder selon le type de code"""
    placeholders = {
        "entity": "Product avec propri√©t√©s name, price, description et validations m√©tier",
        "service": "OrderService pour g√©rer les commandes avec calcul des totaux",
        "repository": "ProductRepository avec MongoDB pour les op√©rations CRUD",
        "controller": "ProductController avec routes GET, POST, PUT, DELETE",
        "test": "UserService avec tous les cas de test et 100% de couverture",
        "middleware": "Authentification JWT avec validation des tokens"
    }
    return placeholders.get(code_type, "D√©crivez votre besoin...")