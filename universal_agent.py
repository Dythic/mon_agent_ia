import os
import json
import pickle
from typing import Dict, List, Optional, Any
from pathlib import Path
from langchain_chroma import Chroma
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_ollama import OllamaLLM
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from code_analyzer import UniversalCodeAnalyzer
from config import UniversalConfig
import requests
import time

class UniversalCodeAgent:
    """Agent IA universel pour analyse et g√©n√©ration de code"""
    
    def __init__(self, project_path: str = None, config_path: str = "config.yaml"):
        self.project_path = project_path
        self.config = UniversalConfig(config_path)
        self.analyzer = UniversalCodeAnalyzer(self.config)
        
        print("ü§ñ Initialisation de l'Agent Universel...")
        
        # Analyse du projet si fourni
        self.project_info = {}
        if project_path and os.path.exists(project_path):
            self.project_info = self.analyzer.analyze_project(project_path)
            print(f"üìÅ Projet analys√©: {self.project_info.get('language', 'Unknown')}")
        
        # Initialisation des composants
        self._setup_llm()
        self._setup_vectorstore()
        self._setup_prompts()
        
        print("‚úÖ Agent Universel pr√™t!")
    
    def _setup_llm(self):
        """Configurer le mod√®le de langage"""
        self._wait_for_ollama()
        self.llm = OllamaLLM(
            model="deepseek-coder:6.7b", 
            temperature=0.2  # Plus d√©terministe pour le code
        )
    
    def _wait_for_ollama(self, max_retries: int = 30):
        """Attendre qu'Ollama soit disponible"""
        print("‚è≥ Connexion √† Ollama...")
        for i in range(max_retries):
            try:
                response = requests.get("http://localhost:11434/api/version", timeout=2)
                if response.status_code == 200:
                    print("‚úÖ Ollama connect√©")
                    return
            except:
                pass
            if i == 0:
                print("‚è≥ Attente de la connexion...")
            time.sleep(1)
        raise Exception("‚ùå Ollama non disponible. Lancez 'ollama serve'")
    
    def _setup_vectorstore(self):
        """Configurer la base vectorielle"""
        print("üìö Configuration de la base vectorielle...")
        
        self.embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2",
            model_kwargs={'device': 'cpu'}
        )
        
        # Chercher une base existante
        db_paths = ["./enhanced_chroma_db", "./chroma_db", "./vector_db"]
        db_path = None
        
        for path in db_paths:
            if os.path.exists(path):
                db_path = path
                break
        
        if db_path:
            self.vectorstore = Chroma(
                persist_directory=db_path,
                embedding_function=self.embeddings
            )
            count = self.vectorstore._collection.count()
            print(f"üìä Base vectorielle charg√©e: {count} documents")
        else:
            print("‚ö†Ô∏è Aucune base vectorielle trouv√©e. Lancez code_indexer.py d'abord.")
            self.vectorstore = None
    
    def _setup_prompts(self):
        """Configurer les prompts selon le projet"""
        
        # Contexte du projet d√©tect√©
        project_context = self._build_project_context()
        
        # Template principal universel
        self.main_template = f"""Tu es un EXPERT D√âVELOPPEUR polyvalent, sp√©cialis√© en g√©n√©ration de code de qualit√©.

{project_context}

CONTEXTE DU CODE:
{{context}}

DEMANDE: {{question}}

INSTRUCTIONS UNIVERSELLES:
1. **Adaptation automatique** : Utilise le langage/framework d√©tect√© du projet
2. **Respect des conventions** : Suis les patterns et styles existants
3. **Code complet** : G√©n√®re du code fonctionnel avec imports/d√©pendances
4. **Qualit√©** : Applique les principes SOLID, DRY, KISS appropri√©s
5. **Tests** : Inclus des tests si demand√© (selon framework d√©tect√©)
6. **Documentation** : Ajoute des commentaires explicatifs

G√âN√âRATION INTELLIGENTE:"""

        # Templates sp√©cialis√©s
        self.templates = {
            'general': PromptTemplate(
                template=self.main_template,
                input_variables=["context", "question"]
            ),
            'code_generation': self._create_code_generation_template(project_context),
            'test_generation': self._create_test_generation_template(project_context),
            'refactoring': self._create_refactoring_template(project_context)
        }
    
    def _build_project_context(self) -> str:
        """Construire le contexte du projet d√©tect√©"""
        if not self.project_info:
            return "PROJET: Non sp√©cifi√© - Mode g√©n√©rique activ√©"
        
        info = self.project_info
        context = f"""PROJET ANALYS√â:
üìÅ Langage principal: {info.get('language', 'Non d√©tect√©')}
üèóÔ∏è Framework: {info.get('framework', 'Standard')}
üß™ Framework de test: {info.get('test_framework', 'Non d√©tect√©')}
üìä Fichiers: {info.get('total_files', 0)} total, {info.get('test_files', 0)} tests
üéØ Conventions: {', '.join(info.get('conventions', ['Standard']))}
üìà Complexit√©: {info.get('avg_complexity', 0):.1f}
üîß Patterns d√©tect√©s: {', '.join(info.get('patterns', ['Standard']))}"""
        
        return context
    
    def _create_code_generation_template(self, project_context: str) -> PromptTemplate:
        """Template pour g√©n√©ration de code"""
        template = f"""Tu es un G√âN√âRATEUR DE CODE EXPERT qui s'adapte automatiquement au projet.

{project_context}

CONTEXTE DU CODE:
{{context}}

DEMANDE DE CODE: {{question}}

G√âN√âRATION ADAPTATIVE:
1. **D√©tection auto** : Utilise le langage/framework d√©tect√© ci-dessus
2. **Style coh√©rent** : Respecte les conventions du projet existant
3. **Code production** : G√©n√®re du code pr√™t √† l'emploi
4. **Imports** : Inclus toutes les d√©pendances n√©cessaires
5. **Robustesse** : Gestion d'erreurs et validation
6. **Performance** : Code optimis√© et bonnes pratiques

CODE G√âN√âR√â ADAPTATIF:"""

        return PromptTemplate(template=template, input_variables=["context", "question"])
    
    def _create_test_generation_template(self, project_context: str) -> PromptTemplate:
        """Template pour g√©n√©ration de tests"""
        template = f"""Tu es un EXPERT EN TESTS qui g√©n√®re des tests adapt√©s au framework d√©tect√©.

{project_context}

CODE √Ä TESTER:
{{context}}

DEMANDE DE TESTS: {{question}}

G√âN√âRATION DE TESTS INTELLIGENTE:
1. **Framework adaptatif** : Utilise le framework de test d√©tect√© (pytest/Jest/JUnit/etc.)
2. **Couverture 100%** : Teste toutes les m√©thodes et cas limites
3. **Format standardis√©** : Given-When-Then ou AAA selon les conventions
4. **Mocking intelligent** : Mock appropri√© selon l'architecture
5. **Tests d'int√©gration** : Si applicable au contexte
6. **Performance** : Tests de charge si pertinents

TESTS G√âN√àRES ADAPT√âS:"""

        return PromptTemplate(template=template, input_variables=["context", "question"])
    
    def _create_refactoring_template(self, project_context: str) -> PromptTemplate:
        """Template pour refactoring"""
        template = f"""Tu es un EXPERT EN REFACTORING qui am√©liore le code selon les bonnes pratiques.

{project_context}

CODE ACTUEL:
{{context}}

DEMANDE DE REFACTORING: {{question}}

REFACTORING INTELLIGENT:
1. **Principes universels** : Applique SOLID, DRY, KISS selon le langage
2. **Patterns appropri√©s** : Utilise les design patterns adapt√©s
3. **Performance** : Optimise selon les sp√©cificit√©s du langage/framework
4. **Lisibilit√©** : Am√©liore la structure et nommage
5. **Maintenabilit√©** : R√©duit la complexit√© et le couplage
6. **Compatibilit√©** : Pr√©serve l'API existante si possible

CODE REFACTORIS√â:"""

        return PromptTemplate(template=template, input_variables=["context", "question"])
    
    def detect_query_type(self, question: str) -> str:
        """D√©tecter le type de requ√™te"""
        question_lower = question.lower()
        
        # Mots-cl√©s pour chaque type
        code_keywords = ['g√©n√®re', 'cr√©e', '√©cris', 'code', 'impl√©mente', 'd√©veloppe', 'classe', 'fonction']
        test_keywords = ['test', 'tests', 'jest', 'pytest', 'junit', 'coverage', 'mock', 'given when then']
        refactor_keywords = ['refactor', 'am√©liore', 'optimise', 'clean', 'restructure', 'solid', 'dry']
        
        if any(keyword in question_lower for keyword in test_keywords):
            return 'test_generation'
        elif any(keyword in question_lower for keyword in refactor_keywords):
            return 'refactoring'
        elif any(keyword in question_lower for keyword in code_keywords):
            return 'code_generation'
        else:
            return 'general'
    
    def ask(self, question: str, query_type: str = None) -> str:
        """Poser une question √† l'agent"""
        if not query_type:
            query_type = self.detect_query_type(question)
        
        # S√©lectionner le prompt appropri√©
        prompt = self.templates.get(query_type, self.templates['general'])
        
        # Si pas de vectorstore, r√©ponse directe
        if not self.vectorstore:
            return self._direct_response(question, prompt)
        
        # Utiliser RAG avec vectorstore
        qa_chain = RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type="stuff",
            retriever=self.vectorstore.as_retriever(search_kwargs={"k": 8}),
            chain_type_kwargs={"prompt": prompt}
        )
        
        try:
            result = qa_chain.invoke({"query": question})
            return result["result"]
        except Exception as e:
            return f"‚ùå Erreur: {e}"
    
    def _direct_response(self, question: str, prompt: PromptTemplate) -> str:
        """R√©ponse directe sans RAG"""
        context = "Aucun contexte de code disponible - g√©n√©ration bas√©e sur les bonnes pratiques universelles."
        formatted_prompt = prompt.format(context=context, question=question)
        
        try:
            return self.llm(formatted_prompt)
        except Exception as e:
            return f"‚ùå Erreur: {e}"
    
    def generate_code(self, specification: str, code_type: str = None) -> str:
        """G√©n√©rer du code selon une sp√©cification"""
        if code_type:
            question = f"G√©n√®re un {code_type} : {specification}"
        else:
            question = f"G√©n√®re le code suivant : {specification}"
        
        return self.ask(question, 'code_generation')
    
    def generate_tests(self, code_or_specification: str) -> str:
        """G√©n√©rer des tests pour du code"""
        question = f"G√©n√®re tous les tests pour : {code_or_specification}"
        return self.ask(question, 'test_generation')
    
    def refactor_code(self, code: str, improvements: str = "") -> str:
        """Refactoriser du code"""
        question = f"Refactorise ce code {improvements}: {code}"
        return self.ask(question, 'refactoring')
    
    def get_project_summary(self) -> str:
        """Obtenir un r√©sum√© du projet"""
        if not self.project_info:
            return "Aucun projet analys√©. Utilisez code_indexer.py pour analyser votre projet."
        
        info = self.project_info
        return f"""
üèóÔ∏è R√âSUM√â DU PROJET:
üìÅ Langage: {info.get('language', 'Non d√©tect√©')}
üõ†Ô∏è Framework: {info.get('framework', 'Standard')}
üìä Fichiers: {info.get('total_files', 0)} total, {info.get('test_files', 0)} tests
üß™ Tests: {info.get('test_coverage', 0):.1%} de couverture
üìà Complexit√©: {info.get('avg_complexity', 0):.1f} (moyenne)
üéØ √âtat: {"‚úÖ Bonne qualit√©" if info.get('quality_score', 0) > 7 else "‚ö†Ô∏è Am√©liorations possibles"}
üîß Patterns: {', '.join(info.get('patterns', ['Standard']))}
"""

def main():
    """Interface en ligne de commande"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Agent IA Universel pour g√©n√©ration de code')
    parser.add_argument('--project', '-p', help='Chemin vers le projet √† analyser')
    parser.add_argument('--config', '-c', default='config.yaml', help='Fichier de configuration')
    args = parser.parse_args()
    
    try:
        # Initialiser l'agent
        agent = UniversalCodeAgent(args.project, args.config)
        
        print("\n" + "="*70)
        print("ü§ñ AGENT IA UNIVERSEL - G√âN√âRATION DE CODE")
        print("="*70)
        
        # Afficher le r√©sum√© du projet
        print(agent.get_project_summary())
        
        print("\nüí° EXEMPLES D'UTILISATION:")
        print("- 'G√©n√®re une classe User avec validation'")
        print("- 'Cr√©e des tests pour cette fonction'") 
        print("- 'Refactorise ce code selon SOLID'")
        print("- 'Explique ce pattern de code'")
        
        # Boucle interactive
        while True:
            question = input("\nüéØ Votre demande (ou 'quit'): ")
            if question.lower() in ['quit', 'exit', 'q']:
                break
            
            query_type = agent.detect_query_type(question)
            print(f"üîç Type d√©tect√©: {query_type}")
            print("üí≠ Traitement...")
            
            answer = agent.ask(question, query_type)
            print(f"\nü§ñ Agent ({query_type}):\n{answer}")
    
    except Exception as e:
        print(f"‚ùå Erreur: {e}")

if __name__ == "__main__":
    main()